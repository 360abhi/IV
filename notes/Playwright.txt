Playwright Architecture
Playwright has a 3-layer architecture:
1.	Client Bindings (Language layer)
o	Your test scripts (Python, Java, C#, or JS).
o	Example: page.click("#login-btn")
o	These are just API calls in your language.
2.	Driver (Playwright Core ‚Äì Node.js)
o	Playwright‚Äôs brain is written in Node.js.
o	No matter if you write in Python, Java, or .NET ‚Üí your commands are sent to this Node core driver.
o	It translates your test commands into browser-protocol messages.
3.	Browser Layer
o	Driver communicates with browsers via their native DevTools protocols:
ÔÇß	Chromium: Chrome DevTools Protocol (CDP)
ÔÇß	Firefox: patched driver via protocol
ÔÇß	WebKit: proprietary automation interface
o	Playwright spawns the browser process and controls it directly.
o	No need for external drivers (unlike Selenium‚Äôs chromedriver/geckodriver).

page.click("#login-btn")
Python Binding ‚Üí sends this command to Playwright Node core.

Node Driver ‚Üí translates click into browser protocol messages.

Browser Protocol ‚Üí browser moves mouse, checks element state, then fires the click.

Response ‚Üí result sent back to Node driver ‚Üí Python binding ‚Üí your test continues.

Aspect	Sync API	Async API
Ease of use	‚úÖ Easier (step-by-step)	‚ùå Requires async/await knowledge
Execution model	Blocking	Non-blocking (can run multiple tasks)
Best for	Normal test cases (UI testing, E2E)	Advanced scenarios (parallel coroutines, scraping, API calls + UI mix)
Integration	Works well with Pytest (simple)	Needs pytest-asyncio or async test runner
Performance	Slower in parallelism	Better for high concurrency

Quick Note for Pytest Integration:
‚Ä¢	Sync API ‚Üí works directly with pytest.
‚Ä¢	Async API ‚Üí requires plugin pytest-asyncio.
Launching a Browser
Sync Example:
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)   # Launch Chromium in headed mode
    page = browser.new_page()
    page.goto("https://example.com")
    browser.close()
In Playwright, BrowserContext ‚âà Incognito window.
‚Ä¢	A browser can have multiple contexts.
‚Ä¢	Each context is isolated: no shared cookies, localStorage, or cache.
‚Ä¢	It‚Äôs like opening multiple private/incognito windows inside the same browser process.
üëâ Each context can have its own authentication, cookies, sessions, etc.
üëâ This is much faster than launching multiple browsers.

‚úÖ Pages in Playwright
‚Ä¢	Page = a single tab inside a browser context.
‚Ä¢	You can open multiple pages within the same context.
with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)
    context = browser.new_context()

    page1 = context.new_page()   # new tab
    page1.goto("https://example.com")

page.goto("https://example.com", timeout=60000, wait_until="networkidle")

wait_until ‚Üí When navigation is considered finished. Possible values:
‚Ä¢	"load" ‚Üí page‚Äôs load event is fired.
‚Ä¢	"domcontentloaded" ‚Üí DOM loaded (but not images, etc).
‚Ä¢	"networkidle" ‚Üí no network requests for 500ms.
‚Ä¢	"commit" ‚Üí when the request is sent, not waiting for load.
1. Wait for Selector
page.wait_for_selector("h1")   # waits until <h1> appears in DOM
2. Wait for Timeout
page.wait_for_timeout(2000)   # pause for 2 seconds (not recommended for real tests)
3. Wait for Event
page.wait_for_event("popup")   # waits for new tab/window
4. Wait for Load State
page.goto("https://example.com")
page.wait_for_load_state("networkidle")  # waits until no network activity


## skip opening new tab or page:
def zen(self,locator:str):
    with self.page.expect_popup() as popup_info:
        self.page.click(f'{locator}')
    popup = popup_info.value
    url = popup.url
    popup.close()
    self.page.goto(url)

‚úÖ Common Actions
1. Click
page.locator("button#login").click()
2. Type vs Fill
‚Ä¢	type() ‚Üí types one key at a time (slower, like user typing).
‚Ä¢	fill() ‚Üí directly replaces value (faster).
page.locator("#username").type("abhishek")   # types char by char
page.locator("#username").fill("abhishek")   # directly fills
üëâ Use .fill() for speed in automation unless you want to test real typing speed.
3. Hover
page.locator("button#menu").hover()
4. Double-Click
page.locator("button#edit").dblclick()
5. Check / Uncheck
For checkboxes & radio buttons:
page.locator("#agree").check()
page.locator("#agree").uncheck()
üëâ Works only on checkable elements.
Advanced Actions
1. File Upload
page.locator("input[type='file']").set_input_files("resume.pdf")
üëâ To remove uploaded file:
page.locator("input[type='file']").set_input_files([])

2. Drag and Drop
page.drag_and_drop("#source", "#target")

Auto-Waiting (Playwright Magic ‚ú®)
‚Ä¢	Playwright automatically waits for elements to:
o	Be attached to DOM
o	Be visible (not hidden/covered)
o	Be stable (not moving/animating)
o	Be enabled (not disabled)
‚Ä¢	If element doesn‚Äôt appear within default timeout (30s) ‚Üí test fails.
You can override with:
‚Ä¢	page.set_default_timeout(10000)   # 10s

Indexed Locators
If multiple elements match, you can pick by index:
page.locator("button").nth(0).click()   # first button
page.locator("button").nth(-1).click()  # last button


1. Built-in Assertions
Playwright provides auto-waiting, retry-able assertions via expect().
These assertions wait until condition is met (default: 5s timeout).
Example
from playwright.sync_api import expect

# Locator assertion
expect(page.locator("h1")).to_have_text("Welcome")

# Page-level assertion
expect(page).to_have_title("Dashboard")
expect(page).to_have_url("https://example.com/dashboard")

expect(locator).to_be_visible()      # Check element visible
expect(locator).to_be_hidden()       # Opposite of above
expect(locator).to_be_enabled()      # Enabled
expect(locator).to_be_disabled()     # Disabled
expect(locator).to_be_checked()      # For checkboxes/radio
expect(locator).to_have_text("...")  # Exact text
expect(locator).to_contain_text("...") # Substring
expect(locator).to_have_attribute("href", "/login") # Attribute value
expect(locator).to_have_class("active") # CSS class
expect(locator).to_have_count(3)     # Number of elements

Soft Assertion
‚Ä¢	Marks failure but continues execution. Useful for multiple validations.
expect(page.locator("h1")).to_have_text("Welcome", soft=True)
expect(page.locator("h2")).to_have_text("Subheading", soft=True)


5. Screenshot & Element Validation
Full Page Screenshot
page.screenshot(path="screenshot.png", full_page=True)
Element Screenshot
page.locator("h1").screenshot(path="element.png")


Screenshot Assertion (Visual Regression)
expect(page).to_have_screenshot("homepage.png")
expect(page.locator("h1")).to_have_screenshot("header.png")
‚Ä¢	Compares current screenshot with baseline image stored in repo.
‚Ä¢	If mismatch > threshold ‚Üí test fails.
Radio Buttons & Checkboxes
# Check / Uncheck checkbox
page.check("#subscribe")        # Ensures checked
page.uncheck("#subscribe")   
3. Frames & iFrames
Many sites embed content in iframes. Playwright supports them directly.
Switching to frame:
frame = page.frame(name="login-frame")
frame.fill("#username", "admin")
frame.click("#submit")
By locator reference:
frame = page.frame_locator("#iframe-id")
frame.locator("#search").fill("Playwright")
üëâ frame_locator() is preferred (auto-wait + chaining).
Dropdown:
# By value
page.locator("select#country").select_option(value="india")

# By label (visible text)
page.locator("select#country").select_option(label="United States")

# By index
page.locator("select#country").select_option(index=2)



Handling JavaScript Dialogs
Playwright automatically listens for dialogs (alerts, confirms, prompts).
You need to attach a handler using page.on("dialog", handler).

Example: Alert
def handle_dialog(dialog):
    print("Dialog message:", dialog.message)
    dialog.accept()

page.on("dialog", handle_dialog)

page.click("#alertButton")  # triggers alert
‚Ä¢	dialog.message ‚Üí gets the text inside alert.
‚Ä¢	dialog.accept() ‚Üí clicks OK.
‚Ä¢	dialog.dismiss() ‚Üí clicks Cancel (useful for confirm).
‚Ä¢	dialog.accept("text") ‚Üí for prompts, you can pass input text.
Handling Multiple Tabs / Popups
When a click opens a new tab or popup, Playwright treats it as a new Page.
Example:
with page.expect_popup() as popup_info:
    page.click("a#open-new-tab")

new_page = popup_info.value
print("New tab title:", new_page.title())


===============================CODE============================
class BrowserManager:
    def __init__(self) -> None:
        self.playwright = sync_playwright().start()
        self.browser: Browser = self.playwright.chromium.launch(headless=False)

    def get_browser(self) -> Browser:
        return self.browser

    def get_page(self, test_case) -> tuple[BrowserContext, Page, Path]:
        unique_id = test_case.get("Test Case ID", "default_id")
        trace_filename = f"{unique_id}_trace.zip"
        trace_path = Path(__file__).parent / "traces" / trace_filename

        context = self.browser.new_context(
            record_video_dir=f"{root_dir}/videos/",
            viewport={"width": 1280, "height": 720},
            record_video_size={"width": 1920, "height": 1080}
        )
        context.tracing.start(screenshots=True, snapshots=True, sources=True)
        print(f"Started tracing for {unique_id}")

        page = context.new_page()
        return context, page, trace_path

    def close_browser(self):
        self.browser.close()
        self.playwright.stop()
        print("Browser and Playwright stopped.")


CONFTEST.PY
@pytest.fixture(scope="session")
def browser_manager():
    manager = BrowserManager()
    yield manager
    manager.close_browser()

@pytest.fixture(scope="function")
def page(request, browser_manager):
    test_case = request.getfixturevalue('test_case')
    context, pg, trace_path = browser_manager.get_page(test_case)

    yield pg
    context.tracing.stop(path=str(trace_path))
    video_path = pg.video.path()
    unique_id = test_case.get("Test Case ID", "unknown_id")
    print(f"Tracing stopped and saved to {trace_path}")
    pg.close()
    context.close()
    shutil.move(video_path,f"{root_dir}/videos/{unique_id}.webm")


UTILS:

def load_page(self,state:str="networkidle",timeout:int=30000):
    self.page.wait_for_load_state(state,timeout=timeout)

GET ELEMENT
element = self.page.locator(locator)
element.wait_for(state="visible", timeout=effective_timeout)
element.wait_for(state="attached", timeout=effective_timeout)
return element

GET ELEMENTS TEXT
elements = self.page.locator(locator)
elements.first.wait_for(state="visible", timeout=effective_timeout)
count = elements.count()
texts = [elements.nth(i).text_content(timeout=effective_timeout) for i in range(count)]

‚ÄÉ
QUESTIONS:

1. What is Playwright, and how is it different from Selenium or Cypress?
‚Ä¢	Playwright: Modern test automation framework by Microsoft, supports Chromium, Firefox, and WebKit.
‚Ä¢	Selenium: Oldest, WebDriver protocol, slower, less auto-wait.
‚Ä¢	Cypress: JS-only, limited browsers, runs inside browser.
‚Ä¢	Playwright Strengths: Auto-waiting, multiple languages, parallel execution, network mocking.
________________________________________
2. Explain Playwright‚Äôs architecture.
‚Ä¢	Node core: Playwright engine written in Node.js.
‚Ä¢	Language bindings: Python/Java/JS/TS.
‚Ä¢	Driver: Communicates with browser via CDP (Chrome DevTools Protocol) or native engines.
________________________________________
3. Sync vs Async APIs in Playwright Python.
‚Ä¢	Sync (playwright.sync_api) ‚Üí step-by-step, simpler for test cases.
‚Ä¢	Async (playwright.async_api) ‚Üí async/await, faster for parallel I/O.
üëâ For testing, Sync is usually preferred.
________________________________________
4. How do you launch browsers in Playwright?
browser = playwright.chromium.launch(headless=False)  # Chromium
context = browser.new_context()
page = context.new_page()
‚Ä¢	headless=True (default) ‚Üí runs without UI.
‚Ä¢	headless=False ‚Üí runs with browser UI.
________________________________________
5. Difference between Browser, Context, and Page?
‚Ä¢	Browser ‚Üí entire browser instance.
‚Ä¢	Context ‚Üí isolated session (like Incognito).
‚Ä¢	Page ‚Üí tab/window inside a context.
üëâ You can create multiple contexts for parallel, isolated tests.
________________________________________
6. How do you navigate and wait for elements in Playwright?
page.goto("https://example.com")
page.wait_for_selector("text=Login")
‚Ä¢	Auto-waiting ‚Üí Playwright waits for elements to be visible/ready.
‚Ä¢	You can also use page.wait_for_load_state("networkidle").
________________________________________
7. Explain Locators in Playwright.
‚Ä¢	page.locator("css=button") ‚Üí core locator.
‚Ä¢	page.get_by_role("button", name="Login") ‚Üí accessible locators.
‚Ä¢	page.get_by_text("Submit") ‚Üí text-based.
________________________________________
8. What is auto-waiting in Playwright?
‚Ä¢	No need for sleep.
‚Ä¢	Playwright automatically waits for elements to:
1.	Be attached to DOM
2.	Be visible
3.	Be enabled
4.	Be stable (not moving)
________________________________________
9. How do you handle dropdowns in Playwright?
page.locator("select#country").select_option("IN")
‚Ä¢	Works with value, label, or index.
________________________________________
10. How do you handle iframes in Playwright?
frame = page.frame(name="frame1")
frame.locator("#insideButton").click()
________________________________________
11. How do you handle Shadow DOM elements?
page.locator("my-element").locator("button").click()
üëâ Playwright pierces shadow DOM automatically, unlike Selenium.
________________________________________
12. How do you handle alerts/dialogs in Playwright?
def handle_dialog(dialog):
    print(dialog.message)
    dialog.accept()

page.on("dialog", handle_dialog)
page.click("#alertButton")
________________________________________
13. How do you handle multiple windows/tabs in Playwright?
with page.expect_popup() as popup_info:
    page.click("a#open-tab")
new_page = popup_info.value
print(new_page.title())
________________________________________
14. What types of assertions are supported in Playwright?
‚Ä¢	Hard assertion (fails immediately):
expect(page.locator("h1")).to_have_text("Welcome")
‚Ä¢	Soft assertion (logs failure but continues):
expect.soft(page.locator("h1")).to_have_text("Welcome")
________________________________________
15. How do you take and attach screenshots?
page.screenshot(path="page.png")
locator = page.locator("#logo")
locator.screenshot(path="logo.png")
üëâ Attach to reports like Allure.
________________________________________
16. How do you record tests in Playwright?
npx playwright codegen https://example.com
üëâ Opens browser, generates code in Python/JS.
________________________________________
17. How do you mock or intercept network requests?
def handle_route(route, request):
    if "api/data" in request.url:
        route.fulfill(status=200, body='{"message":"mocked"}')
    else:
        route.continue_()

page.route("**/api/*", handle_route)
________________________________________
18. How do you run Playwright tests in parallel?
‚Ä¢	Pytest + pytest-xdist for Python:
pytest -n 4
‚Ä¢	Playwright test runner (JS) has built-in parallelism.
________________________________________
19. CI/CD integration of Playwright.
‚Ä¢	Playwright works with Jenkins, GitHub Actions, GitLab CI.
‚Ä¢	Install browsers in pipeline:
npx playwright install --with-deps
________________________________________
20. Most common challenges in Playwright automation.
‚Ä¢	Dynamic locators ‚Üí solve with text/role locators.
‚Ä¢	Flaky waits ‚Üí fixed with auto-wait + expect.
‚Ä¢	Multiple contexts ‚Üí manage with fixtures.
‚Ä¢	Network mocking ‚Üí sometimes tricky for GraphQL/websockets.


‚ÄÉ

